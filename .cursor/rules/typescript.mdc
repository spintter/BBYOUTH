---
description: Strict type systems for TypeScript
globs:  **/*.{ts,tsx}
---
# TypeScript Rules

1. Enable strict: true with exactOptionalPropertyTypes in tsconfig.json.
   # Example: { "strict": true, "exactOptionalPropertyTypes": true }.
2. Use branded types for entity identifiers.
   # Example: type UserId = string & { __brand: 'UserId' };
   # AI Suggestion: Suggest branded types for new entity IDs.
3. Implement type-safe event emitters with typed-emitter.
   # Example: import { EventEmitter } from 'typed-emitter'; new EventEmitter<{ click: () => void }>();
4. Validate API responses with Zod schema parsing.
   # Example: const schema = z.object({ id: z.number() }); schema.parse(response);
5. Use satisfies operator for explicit type constraints.
   # Example: const config = { apiKey: 'abc' } satisfies { apiKey: string };
6. Apply template literal types for CSS-in-JS utilities.
   # Example: type Color = `rgb(${number}, ${number}, ${number})`;
7. Implement type predicates with user-defined type guards.
   # Example: function isString(value: unknown): value is string { return typeof value === 'string'; }
8. Use discriminated unions for state management.
   # Example: type State = { status: 'loading' } | { status: 'error'; error: Error };
9. Leverage const assertions for literal type inference.
   # Example: const config = { env: 'production' } as const;
10. Apply utility types for component props manipulation.
    # Example: type ButtonProps = Omit<React.ButtonHTMLAttributes<HTMLButtonElement>, 'type'>;
# Update monthly with Cursor AI: Review TypeScript 5+ features and type system improvements.