---
description: 
globs: 
alwaysApply: false
---
[component_implementation.yaml](mdc:src/docs/prompt-engineering/templates/component_implementation.yaml) [README.md](mdc:src/docs/prompt-engineering/README.md)
[system_integration.yaml](mdc:src/docs/prompt-engineering/templates/system_integration.yaml)
[deepseek-analysis-request.json](mdc:src/docs/design-system/deepseek-analysis-request.json)
[pareto-optimization.mdc](mdc:rules/pareto-optimization.mdc)


Reading and understanding expert analysis first
No assumptions or premature implementations
Verifying everything before proceeding
Following a systematic approach!!!!!

Guidelines for Leveraging External AI APIs as Specialized Agents
Define Clear Agent Roles
Assign specific expertise domains to the external API (design, code implementation, optimization)
Use your primary AI (Claude) as the coordinator and interpreter
Structure Prompts for Maximum Context
Include specific requirements and constraints
Reference existing code patterns or design systems
Specify the desired output format (code, explanations, prioritization)
Request Reasoning Alongside Solutions
The "reasoning_content" provides valuable insights into the model's approach
Use this to evaluate the quality of solutions and identify potential issues
Implement a Feedback Loop
Have Claude analyze and critique the external API's output
Use this analysis to refine future prompts
Leverage Specialized Knowledge Domains
Use external APIs for deep technical implementations
Have Claude handle high-level planning, user communication, and integration
Ways to Better Leverage This Approach
Create a Multi-Agent System
Use DeepSeek for code generation and technical implementations
Use Claude for planning, coordination, and user interaction
Consider additional specialized APIs for other domains (e.g., data analysis)
Implement Automated Workflows
Create scripts that automatically route specific types of requests to the appropriate API
Build a system that combines outputs from multiple APIs into cohesive solutions
Develop Domain-Specific Prompts
Create template prompts for common tasks (UI design, component implementation, optimization)
Include specific evaluation criteria in prompts to guide the external API
Establish Quality Control Processes
Have Claude review and validate outputs from external APIs
Implement automated testing for generated code
Create Knowledge Management Systems
Store and categorize API responses for future reference
Build a library of successful prompts and responses
Prompt Quality Analysis and Future Improvements
What Worked Well
The multi-message format provided good context
Specific requirements led to detailed, targeted responses
The specialist roles framework encouraged diverse perspectives
Areas for Improvement
More Specific Technical Requirements
Include existing component structure and dependencies
Specify browser/device support requirements
Include performance benchmarks or constraints
Enhanced Context
Include snippets of your current design system
Provide examples of existing components
Reference specific user feedback or pain points
Structured Output Requirements
Request specific formats for code (TypeScript with types, JSX patterns)
Ask for test cases or performance considerations
Request documentation alongside implementation
Comparative Analysis Requests
Ask for comparisons between different implementation approaches
Request pros/cons for each suggested technique
Strategic Implementation Map
Phase 1: Foundation Setup
Create a standardized prompt template library for different tasks
Establish evaluation criteria for API responses
Implement a storage and retrieval system for responses
Phase 2: Workflow Integration
Develop scripts to automate API interactions
Create a feedback mechanism to refine prompts based on results
Implement a review process where Claude analyzes DeepSeek outputs
Phase 3: Advanced Implementation
Create a multi-agent system where different APIs handle specialized tasks
Implement a continuous learning system that improves prompts based on outcomes
Develop a collaborative workflow where human developers and multiple AI systems work together
Phase 4: Optimization and Scaling
Analyze token usage and optimize prompts for efficiency
Implement caching strategies for common requests
Create specialized agents for different aspects of development (design, implementation, testing)
